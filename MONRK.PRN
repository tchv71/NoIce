	MACRO-80 3.44	09-Dec-81	PAGE	1


                                ;  MON8080.ASM - 8080 Debug monitor for use with NoICE85 
                                ;  This file may be assembled with the Alfred Arnold assembler. 
                                ;  Available from http://john.ccac.rwth-aachen.de:8000/as/ 
                                ; 
                                ;  Sample command lines (assuming as.exe and p2hex.exe are on path) 
                                ;    asw.exe Mon8080.asm -L -E -g NOICE 
                                ;       Where 
                                ;       -L           generate a listing file Mon8080.lst 
                                ;       -E           generate an error.log file (errors are also shown in the listing) 
                                ;       -g NOICE     generate a NoICE debug file. 
                                ; 
                                ;    p2hex Mon8080.p Mon8080.hex -F Intel 
                                ;       Where 
                                ;       -F Intel     Intel hex Output 
                                ; 
                                        .8080 ;CPU 8080        ; Specify architecture 
                                ; 
                                ;  Copyright (c) 2000-2022 by John Hartman 
                                ; 
                                ;  Modification History: 
                                ;       14-Jun-2000 ported from Z80 
                                ;       21-Jul-2000 JLH change FN_MIN from F7 to F0 
                                ;       12-Mar-2001 JLH V3.0: improve text about paging, formerly called "mapping" 
                                ;        9-Nov-2021 JLH tweak for Alfred Arnold assembler 
                                ;       20-Nov-2021 JWD Cleanup and fixes specific to 8080 
                                ;       26-Jan-2022 JLH Cleanup and clarifying comments 
                                ; 
                                ; NOTE: review "TODO" notes for things you may need to modify for your hardware. 
                                ; 
                                ;============================================================================ 
                                ; 
                                ;  TODO: To customize for a given target, you must change code in the 
                                ;  hardware equates, the string TSTG, and the routines RESET and REWDT. 
                                ;  You may or may not need to change GETCHAR, PUTCHAR, depending on 
                                ;  how peculiar your UART is. 
                                ; 
                                ;  For more information, refer to the NoICE help file monitor.htm 
                                ; 
                                ;  To add banked or paged memory support: 
                                ;  1) Define page latch port PAGELATCH here 
                                ;  2) If PAGELATCH is write only, define or import the latch port's RAM 
                                ;     image PAGEIMAGE here (The application code must update PAGEIMAGE 
                                ;     before outputing to PAGELATCH) 
                                ;  3) Search for and modify PAGELATCH, PAGEIMAGE, and REG_PAGE usage below 
                                ;  4) In TSTG below edit "LOW AND HIGH LIMIT OF PAGED MEM" 
                                ;     to appropriate range (typically 4000H to 07FFFH for two-bit MMU) 
                                ; 
                                ;  For more information, refer to the NoICE help file 2bitmmu.htm 
                                ; 
                                ;============================================================================ 
                                ; 
                                ;  Hardware definitions 
  B000                          ROM_START equ 0b000h            ;START OF MONITOR CODE 
                                ;RAM_START equ 7400h             ;START OF MONITOR RAM 
  0008                          USER_CODE equ 8                 ;RST 1 handler 
                                ; 
	MACRO-80 3.44	09-Dec-81	PAGE	1-1


                                ;  Equates for I/O mapped 8250 or 16450 serial port 
  C400                          VV55  equ     0C400h   ;base of 16450 UART 
  0000                          DATA    equ     0       ;  Data register 
  0002                          STAT    equ     2       ;  Status register 
                                ; 
                                ;  Define monitor serial port 
  C402                          SERIAL_STATUS   equ   VV55+STAT 
  C401                          CLIENT_STATUS   equ   VV55+1 
  C400                          SERIAL_DATA   equ   VV55+DATA 
  C403                          SERIAL_CONTROL equ  VV55+3 
                                 
  0001                          RXRDY equ           1         ; MASK FOR RX BUFFER FULL 
  0002                          TXRDY equ           2         ; MASK FOR TX BUFFER EMPTY 
                                ; 
                                ;  op-code equates for IN and OUT 
  00DB                          OP_IN   equ     0DBh 
  00D3                          OP_OUT  equ     0D3h 
  00C9                          OP_RET  equ     0C9h 
                                ; 
                                ;=========================================================================== 
                                ; 
                                ;  Main entry point 
                                ; 
                                        ;CSEG 
                                        .PHASE ROM_START;ORG     ROM_START 
  B000    F3                    R0:     DI 
  B001    C3 B00D                       JMP     RESET 
                                ; 
                                ;=========================================================================== 
                                ; 
                                ;  Dummy handler for RST 1.  This code is copied to USER_RAM, where the 
                                ;  RST 1 interrupt calls it.  The code then enters the monitor, specifying 
                                ;  a STATE value which identifies the interrupt which occurred. 
                                ; 
                                ;  RST 1 is used for breakpoint.  Any other RST may be used instead by 
                                ;  changing the code below and the value of the breakpoint instruction 
                                ;  in the status string TSTG.  If RST NN cannot be used, then CALL may be 
                                ;  used instead. However, this will restrict the placement of breakpoints, 
                                ;  since CALL is a three byte instruciton. 
                                ; 
  B004                          DUMMY_INTS: 
  B004    C3 B007                       JMP     R1 
  0003                          DUMMY_SIZE      equ $-DUMMY_INTS 
                                ; 
  B007    F5                    R1:     PUSH    PSW 
  B008    3E 01                         MVI     A,1                     ;state = 1 (breakpoint) 
  B00A    C3 B0BF                       JMP     INT_ENTRY 
                                ; 
                                ;=========================================================================== 
                                ;  Power on reset 
  B00D                          RESET: 
                                ; 
                                ;  Initialize monitor 
  B00D    31 B2FA               INIT:   LXI     SP,MONSTACK 
                                ; 
                                ;=========================================================================== 
	MACRO-80 3.44	09-Dec-81	PAGE	1-2


                                ;  Perform user hardware initialization here 
                                ;  VV55 does not require initialization 
                                ; 
                                ;=========================================================================== 
                                ;  Initialize user interrupt vectors to point to monitor 
  B010    21 B004                       LXI     H,DUMMY_INTS           ;dummy handler code 
  B013    11 0008                       LXI     D,USER_CODE            ;start of user codespace 
  B016    01 0003                       LXI     B,DUMMY_SIZE           ;number of bytes 
  B019    7E                    I10:    MOV     A,M 
  B01A    12                            STAX    D 
  B01B    23                            INX     H 
  B01C    13                            INX     D 
  B01D    05                            DCR     B 
  B01E    C2 B019                       JNZ     I10 
                                 
                                ;=========================================================================== 
                                ; 
                                ;  Initialize user registers 
  B021    21 B2EA                       LXI     H,INITSTACK 
  B024    22 B2FC                       SHLD    REG_SP                  ;INIT USER'S STACK POINTER 
  B027    AF                            XRA     A 
  B028    67                            MOV     H,A 
  B029    6F                            MOV     L,A 
  B02A    22 B306                       SHLD    REG_PC                  ;INIT ALL REGS TO 0 
  B02D    22 B2FE                       SHLD    REG_HL 
  B030    22 B300                       SHLD    REG_BC 
  B033    22 B302                       SHLD    REG_DE 
  B036    22 B304                       SHLD    REG_PSW 
  B039    32 B2FA                       STA     REG_STATE               ;set state as "RESET" 
                                ; 
                                ;  Initialize memory paging variables and hardware (if any) 
  B03C    32 B2FB                       STA     REG_PAGE                ;page 0 
                                ;;;     STA     PAGEIMAGE 
                                ;;;     OUT     PAGELATCH               ;set hardware page 
                                ; 
                                ; TODO: if you can read interrupt state, you may want to set a different initial value 
  B03F    32 B308                       STA     REG_IM 
                                ; 
                                ;  Set function code for "GO".  Then if we reset after being told to 
                                ;  GO, we will come back with registers so user can see the crash 
  B042    3E FA                         MVI     A,FN_RUN_TARGET 
  B044    32 B309                       STA     COMBUF 
  B047    C3 B1B9                       JMP     RETURN_REGS             ;DUMP REGS, ENTER MONITOR 
                                ; 
                                ;=========================================================================== 
                                ;  Get a character to A 
                                ; 
                                ;  Return A=char, CY=0 if data received 
                                ;         CY=1 if timeout (0.5 seconds) 
                                ; 
                                ;  Uses 4 bytes of stack including return address 
                                ; 
  B04A                          GETCHAR: 
  B04A    3E 99                         mvi     A,99H ; A - input, B - output, Clow, Chigh - input 
  B04C    32 C403                       sta     SERIAL_CONTROL 
  B04F    3E 01                         MVI     A,1 
	MACRO-80 3.44	09-Dec-81	PAGE	1-3


  B051    32 C401                       sta     CLIENT_STATUS 
  B054    D5                            PUSH    D 
  B055    11 8000                       LXI     D,8000h                 ;long timeout 
  B058    1B                    gc10:   DCX     D 
  B059    7A                            MOV     A,D 
  B05A    B3                            ORA     E 
  B05B    CA B072                       JZ      gc90                    ;exit if timeout 
  B05E    3A C402                       LDA     SERIAL_STATUS           ;read device status 
  B061    E6 01                         ANI     RXRDY 
  B063    C2 B058                       JNZ      gc10                    ;not ready yet. 
                                ; 
                                ;  Data received:  return CY=0. data in A 
  B066    AF                            XRA     A                       ;cy=0 
  B067    3A C400                       LDA     SERIAL_DATA             ;read data 
  B06A    F5                            push    psw 
  B06B    AF                            xra     a 
  B06C    32 C401                       STA     CLIENT_STATUS 
  B06F    F1                            pop     psw 
  B070    D1                            POP     D 
  B071    C9                            RET 
                                ; 
                                ;  Timeout:  return CY=1 
  B072    37                    gc90:   STC                             ;cy=1 
  B073    3E 00                         MVI     A,0 
  B075    32 C401                       STA     CLIENT_STATUS 
  B078    D1                            POP     D 
  B079    C9                            RET 
                                ; 
                                ;=========================================================================== 
                                ;  Output character in A 
                                ; 
                                ;  Uses 4 bytes of stack including return address 
                                ; 
  B07A                          PUTCHAR: 
  B07A    F5                            PUSH    PSW                     ;save byte to output 
  B07B    3E 89                         mvi     A,89H ; A - output, B - output, Clow, Chigh - input 
  B07D    32 C403                       sta     SERIAL_CONTROL 
  B080    3E 02                         mvi     a,2 
  B082    32 C401                       sta     CLIENT_STATUS; // Ready to send 
  B085    3A C402               pc10:   LDA     SERIAL_STATUS           ;read device status 
  B088    E6 02                         ANI     TXRDY                   ;rx ready ? 
  B08A    C2 B085                       JNZ     pc10 
                                 
  B08D    F1                            POP     PSW 
  B08E    32 C400                       STA     SERIAL_DATA            ;transmit char - error in wiring! must write to _STATUS 
  B091    AF                            xra     a 
  B092    32 C401                       sta     CLIENT_STATUS 
                                 
  B095    3A C402               pc11:   LDA     SERIAL_STATUS           ; wait for server confirms reading a byte 
  B098    E6 02                         ANI     TXRDY 
  B09A    CA B095                       JZ      pc11 
  B09D    C9                            RET 
                                ; 
                                ;=========================================================================== 
                                ;  Response string for GET TARGET STATUS request 
                                ;  Reply describes target: 
	MACRO-80 3.44	09-Dec-81	PAGE	1-4


  B09E    0E                    TSTG:   DB      14                      ;2: PROCESSOR TYPE = 8085 
  B09F    43                            DB      COMBUF_SIZE             ;3: SIZE OF COMMUNICATIONS BUFFER 
  B0A0    00                            DB      0                       ;4: NO OPTIONS 
  B0A1    0000                          DW      0                       ;5,6: BOTTOM OF PAGED MEM (none) 
  B0A3    0000                          DW      0                       ;7,8: TOP OF PAGED MEM (none) 
  B0A5    01                            DB      B1-B0                   ;9 BREAKPOINT INSTRUCTION LENGTH 
  B0A6    CF                    B0:     RST     1                       ;10+ BREKAPOINT INSTRUCTION 
  B0A7    4E 6F 49 43           B1:     DB     "NoICE 8080 monitor V3.1" ;DESCRIPTION, ZERO 
  B0AB    45 20 38 30           
  B0AF    38 30 20 6D           
  B0B3    6F 6E 69 74           
  B0B7    6F 72 20 56           
  B0BB    33 2E 31              
  B0BE    00                            DB      0 
  0021                          TSTG_SIZE EQU   $ - TSTG                ;SIZE OF STRING 
                                ; 
                                ;=========================================================================== 
                                ;  HARDWARE PLATFORM INDEPENDENT EQUATES AND CODE 
                                ; 
                                ;  Communications function codes. 
  00FF                          FN_GET_STATUS   equ 0FFh    ;reply with device info 
  00FE                          FN_READ_MEM     equ 0FEh    ;reply with data 
  00FD                          FN_WRITE_MEM    equ 0FDh    ;reply with status (+/-) 
  00FC                          FN_READ_REGS    equ 0FCh    ;reply with registers 
  00FB                          FN_WRITE_REGS   equ 0FBh    ;reply with status 
  00FA                          FN_RUN_TARGET   equ 0FAh    ;reply (delayed) with registers 
  00F9                          FN_SET_BYTES    equ 0F9h    ;reply with data (truncate if error) 
  00F8                          FN_IN           equ 0F8h    ;input from port 
  00F7                          FN_OUT          equ 0F7h    ;output to port 
                                ; 
  00F0                          FN_MIN          equ 0F0h    ;MINIMUM RECOGNIZED FUNCTION CODE 
  00F0                          FN_ERROR        equ 0F0h    ;error reply to unknown op-code 
                                ; 
                                ;=========================================================================== 
                                ;  Enter here via RST nn for breakpoint:  PSW, PC are stacked. 
                                ;  Enter with A=interrupt code = processor state 
                                ;  Interrupt status is not changed from user program 
  B0BF                          INT_ENTRY: 
  B0BF    32 B2FA                       STA     REG_STATE       ;save entry state 
                                ; 
                                ;  TODO: if you can read interrupt state, do it here 
  B0C2    AF                            XRA     A               ;ALWAYS 0 IF YOU CAN'T READ THE STATE 
  B0C3    F3                            DI                      ;NO INTERRUPTS ALLOWED HEREAFTER 
  B0C4    32 B308                       STA     REG_IM          ;SAVE INT REG 
                                ; 
                                ;  Save registers in reg block for return to master 
  B0C7    22 B2FE                       SHLD    REG_HL          ;SAVE HL 
  B0CA    E1                            POP     H               ;GET FLAGS IN L, ACCUM IN H 
  B0CB    22 B304                       SHLD    REG_PSW         ;SAVE A AND FLAGS 
                                ; 
                                ;  If entry here was by breakpoint (state=1), then back up the program 
                                ;  counter to point at the breakpoint/RST instruction.  Else leave PC alone. 
                                ;  (If CALL is used for breakpoint, then back up by 3 bytes) 
  B0CE    E1                            POP     H               ;GET PC OF BREAKPOINT/INTERRUPT 
  B0CF    3A B2FA                       LDA     REG_STATE 
  B0D2    3D                            DCR     A 
	MACRO-80 3.44	09-Dec-81	PAGE	1-5


  B0D3    C2 B0D7                       JNZ     NOTBP           ;JIF NOT A BREAKPOINT 
  B0D6    2B                            DCX     H               ;BACK UP PC TO POINT AT BREAKPOINT 
  B0D7    C3 B204               NOTBP:  JMP     ENTER_MON       ;HL POINTS AT BREAKPOINT OPCODE 
                                ; 
                                ;=========================================================================== 
                                ;  Main loop:  wait for command frame from master 
  B0DA    31 B2FA               MAIN:   LXI     SP,MONSTACK     ;CLEAN STACK IS HAPPY STACK 
  B0DD    21 B309                       LXI     H,COMBUF        ;BUILD MESSAGE HERE 
                                ; 
                                ;  First byte is a function code 
  B0E0    CD B04A                       CALL    GETCHAR         ;GET A FUNCTION (uses 6 bytes of stack) 
  B0E3    DA B0DA                       JC      MAIN            ;JIF TIMEOUT: RESYNC 
  B0E6    FE F0                         CPI     FN_MIN 
  B0E8    DA B0DA                       JC      MAIN            ;JIF BELOW MIN: ILLEGAL FUNCTION 
  B0EB    77                            MOV     M,A             ;SAVE FUNCTION CODE 
  B0EC    23                            INX     H 
                                ; 
                                ;  Second byte is data byte count (may be zero) 
  B0ED    CD B04A                       CALL    GETCHAR         ;GET A LENGTH BYTE 
  B0F0    DA B0DA                       JC      MAIN            ;JIF TIMEOUT: RESYNC 
  B0F3    FE 44                         CPI     COMBUF_SIZE+1 
  B0F5    D2 B0DA                       JNC     MAIN            ;JIF TOO LONG: ILLEGAL LENGTH 
  B0F8    77                            MOV     M,A             ;SAVE LENGTH 
  B0F9    23                            INX     H 
  B0FA    B7                            ORA     A 
  B0FB    CA B10B                       JZ      MA80            ;SKIP DATA LOOP IF LENGTH = 0 
                                ; 
                                ;  Loop for data 
  B0FE    47                            MOV     B,A             ;SAVE LENGTH FOR LOOP 
  B0FF    CD B04A               MA10:   CALL    GETCHAR         ;GET A DATA BYTE 
  B102    DA B0DA                       JC      MAIN            ;JIF TIMEOUT: RESYNC 
  B105    77                            MOV     M,A             ;SAVE DATA BYTE 
  B106    23                            INX     H 
  B107    05                            DCR     B 
  B108    C2 B0FF                       JNZ     MA10 
                                ; 
                                ;  Get the checksum 
  B10B    CD B04A               MA80:   CALL    GETCHAR         ;GET THE CHECKSUM 
  B10E    DA B0DA                       JC      MAIN            ;JIF TIMEOUT: RESYNC 
  B111    4F                            MOV     C,A             ;SAVE CHECKSUM 
                                ; 
                                ;  Compare received checksum to that calculated on received buffer 
                                ;  (Sum should be 0) 
  B112    CD B299                       CALL    CHECKSUM 
  B115    81                            ADD     C 
  B116    C2 B0DA                       JNZ     MAIN            ;JIF BAD CHECKSUM 
                                ; 
                                ;  Process the message. 
  B119    3A B309                       LDA     COMBUF+0        ;GET THE FUNCTION CODE 
  B11C    FE FF                         CPI     FN_GET_STATUS 
  B11E    CA B153                       JZ      TARGET_STATUS 
  B121    FE FE                         CPI     FN_READ_MEM 
  B123    CA B169                       JZ      READ_MEM 
  B126    FE FD                         CPI     FN_WRITE_MEM 
  B128    CA B184                       JZ      WRITE_MEM 
  B12B    FE FC                         CPI     FN_READ_REGS 
	MACRO-80 3.44	09-Dec-81	PAGE	1-6


  B12D    CA B1B9                       JZ      READ_REGS 
  B130    FE FB                         CPI     FN_WRITE_REGS 
  B132    CA B1CF                       JZ      WRITE_REGS 
  B135    FE FA                         CPI     FN_RUN_TARGET 
  B137    CA B1E9                       JZ      RUN_TARGET 
  B13A    FE F9                         CPI     FN_SET_BYTES 
  B13C    CA B222                       JZ      SET_BYTES 
  B13F    FE F8                         CPI     FN_IN 
  B141    CA B252                       JZ      IN_PORT 
  B144    FE F7                         CPI     FN_OUT 
  B146    CA B262                       JZ      OUT_PORT 
                                ; 
                                ;  Error: unknown function.  Complain 
  B149    3E F0                         MVI     A,FN_ERROR 
  B14B    32 B309                       STA     COMBUF+0        ;SET FUNCTION AS "ERROR" 
  B14E    3E 01                         MVI     A,1 
  B150    C3 B276                       JMP     SEND_STATUS     ;VALUE IS "ERROR" 
                                 
                                ;=========================================================================== 
                                ; 
                                ;  Target Status:  FN, len 
                                ; 
  B153                          TARGET_STATUS: 
                                ; 
  B153    21 B09E                       LXI     H,TSTG          ;DATA FOR REPLY 
  B156    11 B30A                       LXI     D,COMBUF+1      ;RETURN BUFFER 
  B159    06 21                         MVI     B,TSTG_SIZE     ;LENGTH OF REPLY 
  B15B    78                            MOV     A,B 
  B15C    12                            STAX    D               ;SET SIZE IN REPLY BUFFER 
  B15D    13                            INX     D 
  B15E    7E                    TS10:   MOV     A,M             ;MOVE REPLY DATA TO BUFFER 
  B15F    12                            STAX    D 
  B160    23                            INX     H 
  B161    13                            INX     D 
  B162    05                            DCR     B 
  B163    C2 B15E                       JNZ     TS10 
                                ; 
                                ;  Compute checksum on buffer, and send to master, then return 
  B166    C3 B27E                       JMP     SEND 
                                 
                                ;=========================================================================== 
                                ; 
                                ;  Read Memory:  FN, len, page, Alo, Ahi, Nbytes 
                                ; 
  B169                          READ_MEM: 
                                ; 
                                ;  Set page 
                                ;;      LDA     COMBUF+2 
                                ;;      STA     PAGEIMAGE 
                                ;;      OUT     PAGELATCH 
                                ; 
                                ;  Get address 
  B169    2A B30C                       LHLD    COMBUF+3 
  B16C    3A B30E                       LDA     COMBUF+5                ;NUMBER OF BYTES TO GET 
                                ; 
                                ;  Prepare return buffer: FN (unchanged), LEN, DATA 
	MACRO-80 3.44	09-Dec-81	PAGE	1-7


  B16F    11 B30A                       LXI     D,COMBUF+1              ;POINTER TO LEN, DATA 
  B172    12                            STAX    D                       ;RETURN LENGTH = REQUESTED DATA 
  B173    13                            INX     D 
  B174    B7                            ORA     A 
  B175    CA B181                       JZ      GLP90                   ;JIF NO BYTES TO GET 
                                ; 
                                ;  Read the requested bytes from local memory 
  B178    47                            MOV     B,A 
  B179    7E                    GLP:    MOV     A,M             ;GET BYTE TO A 
  B17A    12                            STAX    D               ;STORE TO RETURN BUFFER 
  B17B    23                            INX     H 
  B17C    13                            INX     D 
  B17D    05                            DCR     B 
  B17E    C2 B179                       JNZ     GLP 
                                ; 
                                ;  Compute checksum on buffer, and send to master, then return 
  B181    C3 B27E               GLP90:  JMP     SEND 
                                 
                                ;=========================================================================== 
                                ; 
                                ;  Write Memory:  FN, len, page, Alo, Ahi, (len-3 bytes of Data) 
                                ; 
                                ;  Uses 2 bytes of stack 
                                ; 
  B184                          WRITE_MEM: 
                                ; 
                                ;  Set page 
                                ;;      LDA     COMBUF+2 
                                ;;      STA     PAGEIMAGE 
                                ;;      OUT     PAGELATCH 
                                ; 
                                ;  Get address 
  B184    11 B30E                       LXI     D,COMBUF+5      ;POINTER TO SOURCE DATA IN MESSAGE 
  B187    2A B30C                       LHLD    COMBUF+3        ;POINTER TO DESTINATION 
  B18A    EB                            XCHG 
                                ; 
  B18B    3A B30A                       LDA     COMBUF+1        ;NUMBER OF BYTES IN MESSAGE 
  B18E    DE 03                         SBI     3               ;LESS PAGE, ADDRLO, ADDRHI 
  B190    CA B1B0                       JZ      WLP50           ;EXIT IF NONE REQUESTED 
                                ; 
                                ;  Write the specified bytes to local memory 
  B193    47                            MOV     B,A 
  B194    C5                            PUSH    B               ;SAVE BYTE COUNTER 
  B195    7E                    WLP10:  MOV     A,M             ;BYTE FROM HOST 
  B196    12                            STAX    D               ;WRITE TO TARGET RAM 
  B197    23                            INX     H 
  B198    13                            INX     D 
  B199    05                            DCR     B 
  B19A    C2 B195                       JNZ     WLP10 
                                ; 
                                ;  Compare to see if the write worked 
  B19D    11 B30E                       LXI     D,COMBUF+5      ;POINTER TO SOURCE DATA IN MESSAGE 
  B1A0    2A B30C                       LHLD    COMBUF+3        ;POINTER TO DESTINATION 
  B1A3    EB                            XCHG 
  B1A4    C1                            POP     B               ;SIZE AGAIN 
                                ; 
	MACRO-80 3.44	09-Dec-81	PAGE	1-8


                                ;  Compare the specified bytes to local memory 
  B1A5    1A                    WLP20:  LDAX    D               ;READ BACK WHAT WE WROTE 
  B1A6    BE                            CMP     M               ;COMPARE TO HOST DATA 
  B1A7    C2 B1B4                       JNZ     WLP80           ;JIF WRITE FAILED 
  B1AA    23                            INX     H 
  B1AB    13                            INX     D 
  B1AC    05                            DCR     B 
  B1AD    C2 B1A5                       JNZ     WLP20 
                                ; 
                                ;  Write succeeded:  return status = 0 
  B1B0    AF                    WLP50:  XRA     A               ;RETURN STATUS = 0 
  B1B1    C3 B1B6                       JMP     WLP90 
                                ; 
                                ;  Write failed:  return status = 1 
  B1B4    3E 01                 WLP80:  MVI      A,1 
                                ; 
                                ;  Return OK status 
  B1B6    C3 B276               WLP90:  JMP     SEND_STATUS 
                                 
                                ;=========================================================================== 
                                ; 
                                ;  Read registers:  FN, len=0 
                                ; 
  B1B9                          READ_REGS: 
                                ; 
                                ;  Enter here from int after "RUN" and "STEP" to return task registers 
  B1B9                          RETURN_REGS: 
  B1B9    21 B2FA                       LXI     H,TASK_REGS     ;REGISTER LIVE HERE 
  B1BC    3E 0F                         MVI     A,T_REGS_SIZE   ;NUMBER OF BYTES 
                                ; 
                                ;  Prepare return buffer: FN (unchanged), LEN, DATA 
  B1BE    11 B30A                       LXI     D,COMBUF+1      ;POINTER TO LEN, DATA 
  B1C1    12                            STAX    D               ;SAVE DATA LENGTH 
  B1C2    13                            INX     D 
                                ; 
                                ;  Copy the registers 
  B1C3    47                            MOV     B,A 
  B1C4    7E                    GRLP:   MOV     A,M             ;GET BYTE TO A 
  B1C5    12                            STAX    D               ;STORE TO RETURN BUFFER 
  B1C6    23                            INX     H 
  B1C7    13                            INX     D 
  B1C8    05                            DCR     B 
  B1C9    C2 B1C4                       JNZ     GRLP 
                                ; 
                                ;  Compute checksum on buffer, and send to master, then return 
  B1CC    C3 B27E                       JMP     SEND 
                                 
                                ;=========================================================================== 
                                ; 
                                ;  Write registers:  FN, len, (register image) 
                                ; 
  B1CF                          WRITE_REGS: 
                                ; 
  B1CF    21 B30B                       LXI     H,COMBUF+2      ;POINTER TO DATA 
  B1D2    3A B30A                       LDA     COMBUF+1        ;NUMBER OF BYTES 
  B1D5    B7                            ORA     A 
	MACRO-80 3.44	09-Dec-81	PAGE	1-9


  B1D6    CA B1E5                       JZ      WRR80           ;JIF NO REGISTERS 
                                ; 
                                ;  Copy the registers 
  B1D9    11 B2FA                       LXI     D,TASK_REGS     ;OUR REGISTERS LIVE HERE 
  B1DC    47                            MOV     B,A 
  B1DD    7E                    WRRLP:  MOV     A,M             ;GET BYTE TO A 
  B1DE    12                            STAX    D               ;STORE TO REGISTER RAM 
  B1DF    23                            INX     H 
  B1E0    13                            INX     D 
  B1E1    05                            DCR     B 
  B1E2    C2 B1DD                       JNZ     WRRLP 
                                ; 
                                ;  Return OK status 
  B1E5    AF                    WRR80:  XRA     A 
  B1E6    C3 B276                       JMP     SEND_STATUS 
                                 
                                ;=========================================================================== 
                                ; 
                                ;  Run Target:  FN, len 
                                ; 
                                ;  Uses 4 bytes of stack 
                                ; 
  B1E9                          RUN_TARGET: 
                                ; 
                                ;  Restore user's page 
                                ;;      LDA     REG_PAGE 
                                ;;      STA     PAGEIMAGE 
                                ;;      OUT     PAGELATCH 
                                ; 
                                ;  Switch to user stack 
  B1E9    2A B2FC                       LHLD    REG_SP          ;BACK TO USER STACK 
  B1EC    F9                            SPHL 
                                 
  B1ED    2A B306                       LHLD    REG_PC          ;USER PC 
  B1F0    E5                            PUSH    H               ;SAVE USER PC FOR RET 
  B1F1    2A B304                       LHLD    REG_PSW 
  B1F4    E5                            PUSH    H               ;SAVE USER A AND FLAGS FOR POP 
                                ; 
                                ;  Restore registers 
  B1F5    2A B300                       LHLD    REG_BC 
  B1F8    44                            MOV     B,H 
  B1F9    4D                            MOV     C,L 
  B1FA    2A B302                       LHLD    REG_DE 
  B1FD    54                            MOV     D,H 
  B1FE    5D                            MOV     E,L 
  B1FF    2A B2FE                       LHLD    REG_HL 
                                ; 
                                ;  TODO: if you read interrupt enable state at INT_ENTRY, use the value in REG_IM 
                                ;  to restore the state before RET 
                                ;        LDA     REG_IM 
                                ;        ANI     SOME-KIND-OF-TEST 
                                ;        JZ      RUTT10         ;JUMP IF USER INTERRUPTS WERE OFF 
                                ; 
                                ;  Return to user with interrupts enabled 
                                ;        POP     PSW 
                                ;        EI                     ;ENABLES AFTER NEXT INSTRUCTION 
	MACRO-80 3.44	09-Dec-81	PAGE	1-10


                                ;        RET 
                                ; 
                                ;  Return to user with interrupts disabled 
  B202    F1                    RUTT10: POP     PSW 
  B203    C9                            RET 
                                 
                                ;=========================================================================== 
                                ; 
                                ;  Common continue point for all monitor entrances 
                                ;  HL = user PC, SP = user stack 
                                ;  REG_STATE has current state, REG_HL, REG_IM, REG_PSW set 
                                ; 
                                ;  Uses 2 bytes of stack 
                                ; 
  B204                          ENTER_MON: 
  B204    22 B306                       SHLD    REG_PC 
  B207    21 0000                       LXI     H,0 
  B20A    39                            DAD     SP 
  B20B    22 B2FC                       SHLD    REG_SP          ;SAVE USER'S STACK POINTER 
  B20E    31 B2FA                       LXI     SP,MONSTACK     ;AND USE OURS INSTEAD 
                                ; 
  B211    60                            MOV     H,B 
  B212    69                            MOV     L,C 
  B213    22 B300                       SHLD    REG_BC 
  B216    62                            MOV     H,D 
  B217    6B                            MOV     L,E 
  B218    22 B302                       SHLD    REG_DE 
                                ; 
                                ;;      LDA     PAGEIMAGE       ;GET CURRENT USER PAGE 
  B21B    AF                            XRA     A               ;...OR NONE IF UNPAGED TARGET 
  B21C    32 B2FB                       STA     REG_PAGE        ;SAVE USER PAGE 
                                ; 
                                ;  Return registers to master 
  B21F    C3 B1B9                       JMP     RETURN_REGS 
                                 
                                ;=========================================================================== 
                                ; 
                                ;  Set target byte(s):  FN, len { (page, alow, ahigh, data), (...)... } 
                                ; 
                                ;  Return has FN, len, (data from memory locations) 
                                ; 
                                ;  If error in insert (memory not writable), abort to return short data 
                                ; 
                                ;  This function is used primarily to set and clear breakpoints 
                                ; 
                                ;  Uses 2 bytes of stack 
                                ; 
  B222                          SET_BYTES: 
                                ; 
  B222    21 B30A                       LXI     H,COMBUF+1 
  B225    46                            MOV     B,M             ;LENGTH = 4*NBYTES 
  B226    23                            INX     H 
  B227    04                            INR     B 
  B228    05                            DCR     B 
  B229    0E 00                         MVI     C,0             ;C GETS COUNT OF INSERTED BYTES 
  B22B    CA B24A                       JZ      SB90            ;JIF NO BYTES (C=0) 
	MACRO-80 3.44	09-Dec-81	PAGE	1-11


  B22E    E5                            PUSH    H               ;RETURN BUFFER 
                                ; 
                                ;  Loop on inserting bytes 
  B22F    7E                    SB10:   MOV     A,M             ;MEMORY PAGE 
  B230    23                            INX     H 
                                ;;      STA     PAGEIMAGE 
                                ;;      OUT     PAGELATCH       ;SET PAGE 
  B231    5E                            MOV     E,M             ;ADDRESS TO DE 
  B232    23                            INX     H 
  B233    56                            MOV     D,M 
  B234    23                            INX     H 
                                ; 
                                ;  Read current data at byte location 
  B235    1A                            LDAX    D               ;READ CURRENT DATA 
  B236    E3                            XTHL 
  B237    77                            MOV     M,A             ;SAVE IN RETURN BUFFER 
  B238    23                            INX     H 
  B239    E3                            XTHL 
                                ; 
                                ;  Insert new data at byte location 
  B23A    7E                            MOV     A,M 
  B23B    12                            STAX    D               ;SET BYTE 
  B23C    1A                            LDAX    D               ;READ IT BACK 
  B23D    BE                            CMP     M               ;COMPARE TO DESIRED VALUE 
  B23E    C2 B24A                       JNZ     SB90            ;BR IF INSERT FAILED: ABORT 
  B241    23                            INX     H 
  B242    0C                            INR     C               ;ELSE COUNT ONE BYTE TO RETURN 
                                ; 
  B243    05                            DCR     B 
  B244    05                            DCR     B 
  B245    05                            DCR     B 
  B246    05                            DCR     B 
  B247    C2 B22F                       JNZ     SB10            ;LOOP FOR ALL BYTES 
                                ; 
                                ;  Return buffer with data from byte locations 
  B24A    79                    SB90:   MOV     A,C 
  B24B    32 B30A                       STA     COMBUF+1        ;SET COUNT OF RETURN BYTES 
  B24E    E1                            POP     H               ;CLEAN STACK 
                                ; 
                                ;  Compute checksum on buffer, and send to master, then return 
  B24F    C3 B27E                       JMP     SEND 
                                 
                                ;=========================================================================== 
                                ; 
                                ;  Input from port:  FN, len, PortAddressLo, PAhi (=0) 
                                ; 
  B252                          IN_PORT: 
                                ; 
                                ;  Port address is at COMBUF+2 (and unused high address+3) 
                                ;  Build "IN PORT" and "RET" around it. 
  B252    3E DB                         MVI     A,OP_IN 
  B254    32 B30A                       STA     COMBUF+1 
  B257    3E C9                         MVI     A,OP_RET 
  B259    32 B30C                       STA     COMBUF+3 
                                ; 
                                ;  Read port value 
	MACRO-80 3.44	09-Dec-81	PAGE	1-12


  B25C    CD B30A                       CALL    COMBUF+1 
                                ; 
                                ;  Return byte read as "status" 
  B25F    C3 B276                       JMP     SEND_STATUS 
                                 
                                ;=========================================================================== 
                                ; 
                                ;  Output to port:  FN, len, PortAddressLo, PAhi (=0), data 
                                ; 
  B262                          OUT_PORT: 
                                ; 
                                ;  Port address is at COMBUF+2, (unused high address+3) 
                                ;  Data to write is at COMBUF+4 
                                ;  Build "OUT PORT" and "RET" in combuffer 
  B262    3E D3                         MVI     A,OP_OUT 
  B264    32 B30A                       STA     COMBUF+1 
  B267    3E C9                         MVI     A,OP_RET 
  B269    32 B30C                       STA     COMBUF+3 
                                ; 
                                ;  Get data 
  B26C    3A B30D                       LDA     COMBUF+4 
                                ; 
                                ;  Write value to port 
  B26F    CD B30A                       CALL    COMBUF+1 
                                ; 
                                ;  Return status of OK 
  B272    AF                            XRA     A 
  B273    C3 B276                       JMP     SEND_STATUS 
                                ; 
                                ;=========================================================================== 
                                ;  Build status return with value from "A" 
                                ; 
  B276                          SEND_STATUS: 
  B276    32 B30B                       STA     COMBUF+2        ;SET STATUS 
  B279    3E 01                         MVI     A,1 
  B27B    32 B30A                       STA     COMBUF+1        ;SET LENGTH 
                                ;;;     JMP     SEND 
                                 
                                ;=========================================================================== 
                                ;  Append checksum to COMBUF and send to master 
                                ; 
                                ;  Uses 6 bytes of stack (not including return address: jumped, not called) 
                                ; 
  B27E    CD B299               SEND:   CALL    CHECKSUM        ;GET A=CHECKSUM, HL->checksum location 
  B281    2F                            CMA 
  B282    3C                            INR     A 
  B283    77                            MOV     M,A             ;STORE NEGATIVE OF CHECKSUM 
                                ; 
                                ;  Send buffer to master 
  B284    21 B309                       LXI     H,COMBUF        ;POINTER TO DATA 
  B287    3A B30A                       LDA     COMBUF+1        ;LENGTH OF DATA 
  B28A    C6 03                         ADI     3               ;PLUS FUNCTION, LENGTH, CHECKSUM 
  B28C    47                            MOV     B,A             ;save count for loop 
  B28D    7E                    SND10:  MOV     A,M 
  B28E    CD B07A                       CALL    PUTCHAR         ;SEND A BYTE (uses 6 bytes of stack) 
  B291    23                            INX     H 
	MACRO-80 3.44	09-Dec-81	PAGE	1-13


  B292    05                            DCR     B 
  B293    C2 B28D                       JNZ     SND10 
  B296    C3 B0DA                       JMP     MAIN            ;BACK TO MAIN LOOP 
                                 
                                ;=========================================================================== 
                                ;  Compute checksum on COMBUF.  COMBUF+1 has length of data, 
                                ;  Also include function byte and length byte 
                                ; 
                                ;  Returns: 
                                ;       A = checksum 
                                ;       HL = pointer to next byte in buffer (checksum location) 
                                ;       B is scratched 
                                ; 
                                ;  Uses 2 bytes of stack including return address 
                                ; 
  B299                          CHECKSUM: 
  B299    21 B309                       LXI     H,COMBUF        ;pointer to buffer 
  B29C    3A B30A                       LDA     COMBUF+1        ;length of message 
  B29F    C6 02                         ADI     2               ;plus function, length 
  B2A1    47                            MOV     B,A             ;save count for loop 
  B2A2    AF                            XRA     A               ;init checksum to 0 
  B2A3    86                    CHK10:  ADD     M 
  B2A4    23                            INX     H 
  B2A5    05                            DCR     B 
  B2A6    C2 B2A3                       JNZ     CHK10           ;loop for all 
  B2A9    C9                            RET                     ;return with checksum in A 
                                 
                                ;============================================================================ 
                                ;  RAM definitions:  top 1K (or less) 
                                        ;DSEG 
                                        ;ORG    RAM_START               ; Monitor RAM 
                                ; 
                                ;  Initial user stack 
                                ;  (Size and location is user option) 
  B2AA                                  DS     64 
  B2EA                          INITSTACK: 
                                ; 
                                ;  Monitor stack 
                                ;  (Calculated use is at most 6 bytes.  Leave plenty of spare) 
  B2EA                                  DS     16 
  B2FA                          MONSTACK: 
                                ; 
                                ;  Target registers:  order must match that in TRG8085.C 
  B2FA                          TASK_REGS: 
  B2FA                          REG_STATE:     DS     1 
  B2FB                          REG_PAGE:      DS     1 
  B2FC                          REG_SP:        DS     2 
  B2FE                          REG_HL:        DS     2 
  B300                          REG_BC:        DS     2 
  B302                          REG_DE:        DS     2 
  B304                          REG_PSW: 
  B304                          REG_FLAGS:     DS     1 
  B305                          REG_A:         DS     1 
  B306                          REG_PC:        DS     2 
  B308                          REG_IM:        DS     1 
  000F                          T_REGS_SIZE equ $ - TASK_REGS 
	MACRO-80 3.44	09-Dec-81	PAGE	1-14


                                 
                                ; 
                                ;  Communications buffer 
                                ;  (Must be at least as long as TASK_REG_SIZE.  Larger values may improve 
                                ;  speed of NoICE memory load and dump commands) 
  0043                          COMBUF_SIZE equ 67              ;DATA SIZE FOR COMM BUFFER 
  B309                          COMBUF:     DS  2+COMBUF_SIZE+1 ;BUFFER ALSO HAS FN, LEN, AND CHECK 
                                ; 
  B34F                          RAM_END     equ $               ;ADDRESS OF TOP+1 OF RAM 
                                ; 
                                 
                                        END     RESET 
	MACRO-80 3.44	09-Dec-81	PAGE	S


Macros:

Symbols:
B0A6 	B0              B0A7 	B1              B299 	CHECKSUM        
B2A3 	CHK10           C401 	CLIENT_STATUS   B309 	COMBUF          
0043 	COMBUF_SIZE     0000 	DATA            B004 	DUMMY_INTS      
0003 	DUMMY_SIZE      B204 	ENTER_MON       00F0 	FN_ERROR        
00FF 	FN_GET_STATUS   00F8 	FN_IN           00F0 	FN_MIN          
00F7 	FN_OUT          00FE 	FN_READ_MEM     00FC 	FN_READ_REGS    
00FA 	FN_RUN_TARGET   00F9 	FN_SET_BYTES    00FD 	FN_WRITE_MEM    
00FB 	FN_WRITE_REGS   B058 	GC10            B072 	GC90            
B04A 	GETCHAR         B179 	GLP             B181 	GLP90           
B1C4 	GRLP            B019 	I10             B00D 	INIT            
B2EA 	INITSTACK       B0BF 	INT_ENTRY       B252 	IN_PORT         
B0FF 	MA10            B10B 	MA80            B0DA 	MAIN            
B2FA 	MONSTACK        B0D7 	NOTBP           00DB 	OP_IN           
00D3 	OP_OUT          00C9 	OP_RET          B262 	OUT_PORT        
B085 	PC10            B095 	PC11            B07A 	PUTCHAR         
B000 	R0              B007 	R1              B34F 	RAM_END         
B169 	READ_MEM        B1B9 	READ_REGS       B305 	REG_A           
B300 	REG_BC          B302 	REG_DE          B304 	REG_FLAGS       
B2FE 	REG_HL          B308 	REG_IM          B2FB 	REG_PAGE        
B306 	REG_PC          B304 	REG_PSW         B2FC 	REG_SP          
B2FA 	REG_STATE       B00D 	RESET           B1B9 	RETURN_REGS     
B000 	ROM_START       B1E9 	RUN_TARGET      B202 	RUTT10          
0001 	RXRDY           B22F 	SB10            B24A 	SB90            
B27E 	SEND            B276 	SEND_STATUS     C403 	SERIAL_CONTROL  
C400 	SERIAL_DATA     C402 	SERIAL_STATUS   B222 	SET_BYTES       
B28D 	SND10           0002 	STAT            B153 	TARGET_STATUS   
B2FA 	TASK_REGS       B15E 	TS10            B09E 	TSTG            
0021 	TSTG_SIZE       0002 	TXRDY           000F 	T_REGS_SIZE     
0008 	USER_CODE       C400 	VV55            B195 	WLP10           
B1A5 	WLP20           B1B0 	WLP50           B1B4 	WLP80           
B1B6 	WLP90           B184 	WRITE_MEM       B1CF 	WRITE_REGS      
B1E5 	WRR80           B1DD 	WRRLP           



No Fatal error(s)


S   B222 	SET_BYTES       
B28D 	SND10           0002 	STAT            B153 	TARGET_STATUS   